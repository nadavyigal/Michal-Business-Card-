#!/usr/bin/env node

/**
 * Creates one PostHog dashboard and a set of unified insights for:
 * - business card page
 * - main website
 * - clinic-for-organizations page
 *
 * Requires:
 * - POSTHOG_PERSONAL_API_KEY
 * - POSTHOG_PROJECT_ID
 * - POSTHOG_HOST (optional, defaults to https://us.posthog.com)
 */

import fs from 'node:fs';
import path from 'node:path';

const loadEnvFile = (filename) => {
  const fullPath = path.resolve(process.cwd(), filename);
  if (!fs.existsSync(fullPath)) return;

  const lines = fs.readFileSync(fullPath, 'utf8').split(/\r?\n/);
  for (const line of lines) {
    if (!line || line.trim().startsWith('#') || !line.includes('=')) continue;
    const [rawKey, ...rest] = line.split('=');
    const key = rawKey.trim();
    let value = rest.join('=').trim();
    if (!key) continue;
    if ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1);
    }
    if (!process.env[key]) process.env[key] = value;
  }
};

const normalizePersonalApiKey = (rawKey) => {
  if (!rawKey) return rawKey;
  const matches = [...rawKey.matchAll(/phx_/g)];
  if (matches.length > 1) {
    return rawKey.slice(0, matches[1].index);
  }
  return rawKey;
};

loadEnvFile('.env.local');
loadEnvFile('.env');

const POSTHOG_HOST = process.env.POSTHOG_HOST || 'https://us.posthog.com';
const POSTHOG_PERSONAL_API_KEY = normalizePersonalApiKey(process.env.POSTHOG_PERSONAL_API_KEY);
const POSTHOG_PROJECT_ID_RAW = process.env.POSTHOG_PROJECT_ID;

if (!POSTHOG_PERSONAL_API_KEY) {
  console.error('Missing POSTHOG_PERSONAL_API_KEY. See .env.example.');
  process.exit(1);
}

const api = async (apiPath, method = 'GET', body = undefined) => {
  const response = await fetch(`${POSTHOG_HOST}${apiPath}`, {
    method,
    headers: {
      Authorization: `Bearer ${POSTHOG_PERSONAL_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: body ? JSON.stringify(body) : undefined,
  });

  if (!response.ok) {
    const details = await response.text();
    throw new Error(`${method} ${apiPath} failed (${response.status}): ${details}`);
  }

  if (response.status === 204) return null;
  return response.json();
};

const resolveProjectId = async () => {
  if (POSTHOG_PROJECT_ID_RAW && /^\d+$/.test(String(POSTHOG_PROJECT_ID_RAW))) {
    return String(POSTHOG_PROJECT_ID_RAW);
  }

  const currentProject = await api('/api/projects/@current/', 'GET');
  if (!currentProject?.id) {
    throw new Error('Could not resolve current PostHog project id via /api/projects/@current/.');
  }

  if (POSTHOG_PROJECT_ID_RAW && String(POSTHOG_PROJECT_ID_RAW).startsWith('phc_')) {
    if (currentProject.api_token !== POSTHOG_PROJECT_ID_RAW) {
      throw new Error(
        'POSTHOG_PROJECT_ID looks like a project API key, but it does not match the current project.'
      );
    }
  }

  return String(currentProject.id);
};

const getOrCreateDashboard = async (projectId) => {
  const dashboardName = 'Michal - Unified Performance';
  const list = await api(`/api/projects/${projectId}/dashboards/?limit=100`, 'GET');
  const existing = list?.results?.find((d) => d.name === dashboardName);
  if (existing) {
    return { dashboard: existing, created: false };
  }

  const created = await api(`/api/projects/${projectId}/dashboards/`, 'POST', {
    name: dashboardName,
    description: 'Unified analytics for business card + website + clinic-for-organizations',
    tags: ['michal', 'unified-dashboard'],
  });
  return { dashboard: created, created: true };
};

const eventFilter = (id, order, properties = undefined) => {
  const event = {
    id,
    name: id,
    type: 'events',
  };
  if (typeof order === 'number') event.order = order;
  if (properties && properties.length) event.properties = properties;
  return event;
};

const propEq = (key, value) => ({
  key,
  type: 'event',
  value,
  operator: 'exact',
});

const trendsInsight = ({ name, events, breakdown = undefined, properties = [] }) => {
  const filters = {
    events: events.map((eventName) => eventFilter(eventName)),
    display: 'ActionsLineGraph',
    interval: 'day',
    date_from: '-30d',
  };
  if (breakdown) filters.breakdown = breakdown;
  if (properties.length) filters.properties = properties;

  return {
    name,
    description: 'Auto-generated by scripts/posthog/create-unified-dashboard.mjs',
    tags: ['michal', 'unified-dashboard'],
    filters,
  };
};

const funnelInsight = ({ name, steps }) => ({
  name,
  description: 'Auto-generated by scripts/posthog/create-unified-dashboard.mjs',
  tags: ['michal', 'unified-dashboard'],
  filters: {
    insight: 'FUNNELS',
    date_from: '-30d',
    events: steps.map((step, index) => eventFilter(step.id, index, step.properties || [])),
  },
});

const insightDefinitions = [
  trendsInsight({
    name: 'Visitors by Property',
    events: ['business_card_page_viewed', 'site_page_viewed'],
    breakdown: 'property',
  }),
  trendsInsight({
    name: 'Traffic Source Mix',
    events: ['business_card_page_viewed', 'site_page_viewed'],
    breakdown: 'utm_source',
  }),
  funnelInsight({
    name: 'Business Card Engagement Funnel',
    steps: [
      { id: 'business_card_page_viewed' },
      { id: 'section_viewed', properties: [propEq('section_id', 'contact')] },
      { id: 'contact_clicked' },
    ],
  }),
  trendsInsight({
    name: 'Resource Clicks by Destination',
    events: ['resource_link_clicked'],
    breakdown: 'resource',
  }),
  trendsInsight({
    name: 'Contact Intent by Channel',
    events: ['contact_clicked'],
    breakdown: 'channel',
  }),
  trendsInsight({
    name: 'Scroll Depth Distribution (Business Card)',
    events: ['scroll_depth_reached'],
    breakdown: 'depth_percent',
    properties: [propEq('property', 'business_card')],
  }),
  trendsInsight({
    name: 'Clinic Landing Performance',
    events: ['site_page_viewed', 'lead_form_started', 'lead_form_submitted'],
    properties: [propEq('property', 'clinic_for_organizations')],
  }),
  funnelInsight({
    name: 'Website to Course Conversion',
    steps: [
      { id: 'site_page_viewed', properties: [propEq('property', 'website')] },
      { id: 'resource_link_clicked', properties: [propEq('resource', 'online_course')] },
      { id: 'lead_form_submitted' },
    ],
  }),
  trendsInsight({
    name: 'Lead Submissions by Property',
    events: ['lead_form_submitted'],
    breakdown: 'property',
  }),
  trendsInsight({
    name: 'Top Pages by Conversion Intent',
    events: ['site_page_viewed', 'contact_clicked', 'resource_link_clicked'],
    breakdown: 'page_path',
  }),
];

const listInsights = async (projectId) => {
  const pageSize = 100;
  let offset = 0;
  let all = [];

  while (true) {
    const data = await api(`/api/projects/${projectId}/insights/?limit=${pageSize}&offset=${offset}`, 'GET');
    all = all.concat(data.results || []);
    if (!data.next) break;
    offset += pageSize;
  }

  return all;
};

const ensureInsightOnDashboard = async (projectId, dashboardId, insightDefinition, existingByName) => {
  const existing = existingByName.get(insightDefinition.name);

  if (!existing) {
    const created = await api(`/api/projects/${projectId}/insights/`, 'POST', {
      ...insightDefinition,
      dashboards: [dashboardId],
    });
    return { action: 'created', insight: created };
  }

  const dashboardIds = (existing.dashboards || []).map((d) => (typeof d === 'object' ? d.id : d));
  if (!dashboardIds.includes(dashboardId)) {
    await api(`/api/projects/${projectId}/insights/${existing.id}/`, 'PATCH', {
      dashboards: [...new Set([...dashboardIds, dashboardId])],
    });
    return { action: 'linked', insight: existing };
  }

  return { action: 'kept', insight: existing };
};

const cleanupSmokeTestInsights = async (projectId, dashboardId) => {
  const insights = await listInsights(projectId);
  const smoke = insights.filter((item) => (item.name || '').includes('Smoke Test'));
  for (const item of smoke) {
    try {
      const dashboards = (item.dashboards || [])
        .map((d) => (typeof d === 'object' ? d.id : d))
        .filter((id) => Number(id) !== Number(dashboardId));

      await api(`/api/projects/${projectId}/insights/${item.id}/`, 'PATCH', {
        dashboards,
      });
      console.log(`- Unlinked temporary insight from dashboard: ${item.name} (id=${item.id})`);
    } catch (error) {
      console.log(`- Could not clean temporary insight ${item.id}; skipping cleanup.`);
    }
  }
};

const run = async () => {
  const projectId = await resolveProjectId();
  const { dashboard, created } = await getOrCreateDashboard(projectId);
  console.log(created ? `Dashboard created (id=${dashboard.id}).` : `Dashboard already exists (id=${dashboard.id}).`);

  const existingInsights = await listInsights(projectId);
  const byName = new Map(existingInsights.map((item) => [item.name, item]));

  console.log('Ensuring unified insights...');
  for (const definition of insightDefinitions) {
    const result = await ensureInsightOnDashboard(projectId, dashboard.id, definition, byName);
    console.log(`- Insight ${result.action}: ${definition.name} (id=${result.insight.id})`);
  }

  await cleanupSmokeTestInsights(projectId, dashboard.id);

  const finalInsights = await listInsights(projectId);
  const dashboardInsightsCount = finalInsights.filter((insight) => {
    const dashboards = (insight.dashboards || []).map((d) => (typeof d === 'object' ? d.id : d));
    return dashboards.includes(dashboard.id);
  }).length;

  if (dashboardInsightsCount < insightDefinitions.length) {
    throw new Error(
      `Dashboard has ${dashboardInsightsCount} insights linked; expected at least ${insightDefinitions.length}.`
    );
  }

  console.log(`Done. Dashboard URL: ${POSTHOG_HOST}/project/${projectId}/dashboard/${dashboard.id}`);
};

run().catch((error) => {
  console.error(error.message);
  process.exit(1);
});
